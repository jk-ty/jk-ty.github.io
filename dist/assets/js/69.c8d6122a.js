(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{1638:function(_,t,v){"use strict";v.r(t);var s=v(6),a=Object(s.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_05-测试用例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_05-测试用例"}},[_._v("#")]),_._v(" 05-测试用例")]),_._v(" "),v("h2",{attrs:{id:"_1、bug-缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、bug-缺陷"}},[_._v("#")]),_._v(" 1、BUG(缺陷)")]),_._v(" "),v("p",[v("strong",[_._v("定义：")])]),_._v(" "),v("p",[_._v("​\t1）从产品内部 看，软件缺陷是软件产品开发或维护的过程中所存在的错误，问题等。")]),_._v(" "),v("p",[_._v("​\t2）从外部看，软件缺陷是系统所需要实现的某种功能失效或违背。")]),_._v(" "),v("p",[_._v("​\t因此软件缺陷就是软件产品中存在的问题，最终表现为用户所需要的功能没有完全实现，没有满足用户的需求")]),_._v(" "),v("p",[v("strong",[_._v("产生原因")]),_._v("：")]),_._v(" "),v("p",[_._v("​\t软件缺陷的产生是不可避免的，造成软件缺陷产生的原因主要归咎于以下几点：")]),_._v(" "),v("p",[_._v("​\t1）用户需求定义错误")]),_._v(" "),v("p",[_._v("​\t2）设计说明存在错误")]),_._v(" "),v("p",[_._v("​\t3）编码说明、程序代码错误")]),_._v(" "),v("p",[_._v("​\t4）硬件或者软件系统上存在错误")]),_._v(" "),v("p",[_._v("​\t5）其他外部原因")]),_._v(" "),v("p",[v("strong",[_._v("根源问题")]),_._v("：")]),_._v(" "),v("p",[_._v("​\t1）交流不充分：客户与产品需求人员，开发人员与测试人员等")]),_._v(" "),v("p",[_._v("​\t2）软件的复杂度：功能复杂，开发复杂，测试复杂")]),_._v(" "),v("p",[_._v("​\t3）开发人员的错误：对需求的理解，开发压力，能力与经验。")]),_._v(" "),v("p",[_._v("​\t4）需求的变化：需求说明书，设计文档，程序的变更，进度压力。")]),_._v(" "),v("p",[_._v("​\t5）项目周期：时间紧任务重")]),_._v(" "),v("h2",{attrs:{id:"_2、测试用例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、测试用例"}},[_._v("#")]),_._v(" 2、测试用例")]),_._v(" "),v("p",[v("strong",[_._v("定义：")])]),_._v(" "),v("p",[_._v("​\t是指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。")]),_._v(" "),v("p",[v("strong",[_._v("内容：")])]),_._v(" "),v("p",[_._v("​\t其内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，最终形成文档。简单地认为，测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，用于核实是否满足某个特定软件需求。它是指导测试工作进行的依据")]),_._v(" "),v("p",[v("strong",[_._v("作用：")])]),_._v(" "),v("p",[_._v("​\t1、提前准备测试数据。")]),_._v(" "),v("p",[_._v("​\t2、查看工作进度，便于对工作进度的安排与调整。")]),_._v(" "),v("p",[_._v("​\t3、理清思路避免重复或遗漏，提高工作效率。")]),_._v(" "),v("p",[_._v("​\t4、历史参考，便于以后复用")]),_._v(" "),v("p",[_._v("​\t5、便于他人理解和工作交接")]),_._v(" "),v("p",[_._v("​\t6、用于工作汇报、演讲体现自我的工作进度")]),_._v(" "),v("h2",{attrs:{id:"_3、测试用例的要素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、测试用例的要素"}},[_._v("#")]),_._v(" 3、测试用例的要素")]),_._v(" "),v("p",[v("strong",[_._v("1). 测试用例编号")]),_._v("\n  编号由字符和数字组合成的字符串,用例编号具有唯一性、容易识别, 如下表\n"),v("strong",[_._v("2).测试模块")]),_._v("\n  测试的项目属于哪个项目或者被测试的需求、被测的模块、被测的单元等等\n"),v("strong",[_._v("3). 预置条件")]),_._v("\n  执行当前测试用例需要的前提条件,如果前提条件不满足,则后面的测试步骤不能进行或者得不到预期结果\n"),v("strong",[_._v("4). 测试输入")]),_._v("\n  测试用例执行过程中需要加工的外部信息.根据测试用例的具体条件有手工输入、数据库等\n"),v("strong",[_._v("5). 预期输出")]),_._v("\n    测试用例的预期输出结果,包括返回值内容、界面响应结果等.\n"),v("strong",[_._v("6). 操作步骤")]),_._v("\n  执行当前测试用例需要经过的操作步骤，需要明确的给出一个步骤的描述，测试用例执行人员可以根据\n该步骤完成测试用例执行\n"),v("strong",[_._v("7). 测试用例标题")]),_._v("\n  对测试用例的简单描述。用概括的语言描述该测试用例的测试点。每个测试用例的标题不能够重复，因\n为每个测试用例的测试点事不一样的。\n"),v("strong",[_._v("8). 级别")]),_._v("\n​\t  对于测试用例的重要程度的区分.包含如下几种:\n高级别\n​\t  保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例\n中级别\n​\t  重要程度介于高和低之间的测试用例\n低级别\n​\t   实际使用的频率不高，对系统业务功能影响不大的模块或功能的测试用例")]),_._v(" "),v("p",[v("strong",[_._v("其他要素")])]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("1. 用例的设计者 :能准确找到测试用例的设计人员,对用例修改时能方便找到人员\n2. 用例设计日期 : 方便检查用例的设计进度\n3. 对应的开发人员 : 出现bug后能及时找到相应的人员进行修复\n4. 测试结果 : 执行用例最后执行的结果, 包括:pass、fail、block\n5. 测试类型 : 功能、性能、压力等等\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br")])]),v("h2",{attrs:{id:"_4、测试用例设计方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、测试用例设计方法"}},[_._v("#")]),_._v(" 4、测试用例设计方法")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("等价类划分话、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果图法\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("h2",{attrs:{id:"_5、等价类划分法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、等价类划分法"}},[_._v("#")]),_._v(" 5、等价类划分法")]),_._v(" "),v("p",[v("strong",[_._v("概念：")])]),_._v(" "),v("p",[_._v("​\t等价类划分就是把被测对象的输入区域划分为若干个集合，然后从每个划分的集合中取出少数的数据作为测试的用例")]),_._v(" "),v("p",[_._v("使用场景：")]),_._v(" "),v("p",[_._v("​\t有数据输入（编辑框）的地方，可以使用等价类划分法。例如用户登录的输入框、注册的输入框、添加数据的输入框、查找的输入框。")]),_._v(" "),v("p",[v("strong",[_._v("分类：")])]),_._v(" "),v("p",[_._v("​\t有效等价类（正向）：")]),_._v(" "),v("p",[_._v("​\t\t对程序正确的，有意义的合理数据")]),_._v(" "),v("p",[_._v("​\t无效等价类（反向）：")]),_._v(" "),v("p",[_._v("​\t\t对程序错误的，无意义和不合理的数据。")]),_._v(" "),v("p",[v("strong",[_._v("特点:")])]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[_._v("有效等价类中一条测试用例尽可能覆盖尚未覆盖的有效等价类\n\n无效等价类中一条测试用例只能覆盖一个未覆盖的无效等价类\n")])])]),v("p",[v("strong",[_._v("优点：")])]),_._v(" "),v("p",[_._v("​\t等价类划分的测试用例设计方法减少了穷举法带来的大量测试用例，保证测试效果和测试效率，一般是有输入性需求的被测对象可以采用的方法；")]),_._v(" "),v("p",[v("strong",[_._v("缺点：")])]),_._v(" "),v("p",[_._v("​\t输入与输入之间的关系考虑少，可能产生一些逻辑错误。还需要其他用例设计方法来补充测试。")]),_._v(" "),v("h2",{attrs:{id:"_6、边界值法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、边界值法"}},[_._v("#")]),_._v(" 6、边界值法")]),_._v(" "),v("p",[_._v("​\t边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，通常输入和输出等价类的边界，就是应着重测试的边界情况。")]),_._v(" "),v("p",[v("strong",[_._v("边界值分析法与等价类分析法的区别")]),_._v("：")]),_._v(" "),v("p",[_._v("​\t1)边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。")]),_._v(" "),v("p",[_._v("​\t2) 边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。")]),_._v(" "),v("p",[v("strong",[_._v("软件测试所包含的边界检验有几种类型：")])]),_._v(" "),v("p",[_._v("​\t数字、 字符、 位置、重量、大小、速度、方位、尺寸、 空间")]),_._v(" "),v("p",[v("strong",[_._v("相应地，以上类型的边界值应该")]),_._v("在：")]),_._v(" "),v("p",[_._v("​\t最大/最小、最短/最长、上/下、  最重/最轻   最大/最小  最快/最慢、 最高/最低、最短/最长、空/满等情况下，利用边界值作为测试数据。")]),_._v(" "),v("p",[v("strong",[_._v("基于边界值分析方法选择测试用例的原则：")])]),_._v(" "),v("p",[_._v("​\t1)如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。")]),_._v(" "),v("p",[_._v("​\t2)如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一,比最大个数多一的数作为测试数据。")]),_._v(" "),v("p",[_._v("​\t3)将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。")]),_._v(" "),v("p",[_._v("​\t4)如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例。")]),_._v(" "),v("p",[_._v("​\t5)如果程序中使用了一个内部数据结构,则应当选择这个内部数据结构的边界上的值作为测试用例。")]),_._v(" "),v("p",[_._v("​\t6) 分析规格说明,找出其它可能的边界条件。")]),_._v(" "),v("p",[v("strong",[_._v("用例说明：")])]),_._v(" "),v("p",[_._v("​\t在等价类边界上以及两侧的边界设计测试用例。取的值刚达到这个范围的边界值，以及刚刚超过这个边界值做为测试的输入数据，一般都是大一的数，或是取小一的数做为测试数据。")]),_._v(" "),v("h2",{attrs:{id:"_7、判定表法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7、判定表法"}},[_._v("#")]),_._v(" 7、判定表法")]),_._v(" "),v("p",[v("strong",[_._v("判定表：")])]),_._v(" "),v("p",[_._v("​\t是分析和表达多逻辑条件下执行不同操作的工具。判定表是由条件桩、动作桩、条件项、动作项四部分组成的表格")]),_._v(" "),v("p",[_._v("​\t1）条件桩：列出了所有条件，通常认为列出条件的次序无关紧要")]),_._v(" "),v("p",[_._v("​\t2）动作桩：列出所有可能的操作，这些操作的排列顺序没有约束")]),_._v(" "),v("p",[_._v("​\t3）条件项：列出了所有条件的取值组合，在所有可能情况下的真假值")]),_._v(" "),v("p",[_._v("​\t4）动作项：列出在条件项的各种取值情况下应该采取的动作。")]),_._v(" "),v("p",[v("strong",[_._v("规则：")])]),_._v(" "),v("p",[_._v("​\t任何一个条件组合的特定取值及其他相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。")]),_._v(" "),v("p",[v("strong",[_._v("判定表的化简：")])]),_._v(" "),v("p",[_._v("​\t合并判定表中两条或多条具有相同动作，并且其条件项之间存在着极为相似关系的规则这一过程。")]),_._v(" "),v("p",[v("strong",[_._v("判定表使用场景：")])]),_._v(" "),v("p",[_._v("​\t如果程序中多个条件决定一个动作，并且每个条件的取值只有两种，且条件和动作之间的逻辑关系明确")]),_._v(" "),v("p",[v("strong",[_._v("优点：")])]),_._v(" "),v("p",[_._v("​\t能够将复杂的问题按照各种可能的情况全部列举出来，简明并且可以避免遗漏。")]),_._v(" "),v("p",[v("strong",[_._v("判定表的建立步骤：")])]),_._v(" "),v("p",[_._v("​\t1）列出所有的条件和动作")]),_._v(" "),v("p",[_._v("​\t2）确定规则的个数（假如有n个条件，每个条件有2个取值（0、1），就可以产生2的n次方种规则）")]),_._v(" "),v("p",[_._v("​\t3）填写判定表")]),_._v(" "),v("p",[_._v("​\t4）化简判定表")]),_._v(" "),v("h2",{attrs:{id:"_8、因果图法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8、因果图法"}},[_._v("#")]),_._v(" 8、因果图法")]),_._v(" "),v("p",[_._v("​\t因果图分析法又叫鱼骨图分析法，它是对问题的根因 进行分析的方法，透过现象看本质的方法：通往判定表的中间过程")]),_._v(" "),v("p",[_._v("​\t因果图是一种利用图解法分析输入的各种组合情况，从而进行测试用例设计。")]),_._v(" "),v("p",[_._v("​\t等价类和边界值分析法同样是对输入条件的测试分析，但其输入条件之间并不存在任何关联或约束，且必须相互独立(等价类的原则之一)。")]),_._v(" "),v("h3",{attrs:{id:"因果图特有的术语和语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#因果图特有的术语和语法"}},[_._v("#")]),_._v(" 因果图特有的术语和语法")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v(" 恒等（是1则1）：若原因出现，则结果出现；若原因不出现，则结果也不出现。\n 非~（是1则0）：若原因出现，则结果不出现；若原因不出现，则结果出现。\n 或 U（其中一个是1则结果为1）：若原因中的一个有出现，则结果出现，若所有原因都不出现，则结果不出现\n 与 ^（全部为1才是1）:若所有原因都出现，则结果出现；若原因中的一个不出现，则结果不出现。\n 异或/互斥(Exclusive)：C1/C2/C3中至多为1\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br")])]),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("(1). 输入条件约束\n\nE(exclude) 约束: a和b中至多有一个为1.\nI(include) 包含: a、b和c中至少有一个必须是1.\nR(required) 要求: a是1时，b必须是1.\nO(only) 唯一: a和b必须有一个，且仅有1个为1.\n\n(2). 输出条件约束\nM(mandatory) 强制: 若结果a是1,结果b强制为0.\n\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br"),v("span",{staticClass:"line-number"},[_._v("6")]),v("br"),v("span",{staticClass:"line-number"},[_._v("7")]),v("br"),v("span",{staticClass:"line-number"},[_._v("8")]),v("br"),v("span",{staticClass:"line-number"},[_._v("9")]),v("br"),v("span",{staticClass:"line-number"},[_._v("10")]),v("br")])]),v("h2",{attrs:{id:"_9、正交表-正交试验-法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9、正交表-正交试验-法"}},[_._v("#")]),_._v(" 9、正交表（正交试验）法")]),_._v(" "),v("p",[_._v("​\t在最优化思想指导下，进行最优设计。从不同组合的优良性触发，合理设计测试方案。有效控制测试干扰，科学处理测试数据。")]),_._v(" "),v("p",[_._v("正交设计的特点是：")]),_._v(" "),v("p",[_._v("​\t用部分代表性测试用例替代全面覆盖测试，通过对部分测试结果的分析了解全面的测试情况。")]),_._v(" "),v("h2",{attrs:{id:"_10、场景法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10、场景法"}},[_._v("#")]),_._v(" 10、场景法")]),_._v(" "),v("p",[_._v("基本流和备选流：")]),_._v(" "),v("p",[_._v("​\t1.基本流：软件功能按照正确的事件流，中间无任何差错，从开始直接执行到结束的一条正确流程")]),_._v(" "),v("p",[_._v("​\t2.备选流：软件功能在执行过程中，除了基本流之外可能遇到的各种情况，是包含可能存在问题的各支流")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("场景法的使用步骤如下:\n（1）分析需求，根据需求说明描述出程序的基本流及各项备选流\n（2）根据基本流和各项备选流生成不同的场景\n（3）针对每一个场景生成相应的测试用例\n（4）重新审核生成的所有测试用例，把多余的测试用例去掉，确定好每一个测试用例，并设计测试数据\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br")])])])}),[],!1,null,null,null);t.default=a.exports}}]);